<p>
  В поле для поиска введите искомое слово, фразу или составьте поисковый запрос.
  С помощью несложного синтаксиса можно построить запрос, который найдет иммено то что нужно.
</p>

<h3><a id="word"><%= l('es.word') %></a></h3>

  Для поиска можно ввести искомое слово полностью

  <p class="search-phrase">электричка</p>

  или его часть (начальную):

  <p class="search-phrase">электр</p>

  Поиск слова или его части по умолчанию осуществляется по следующим полям:

  <ul>
    <li>title(<%= l(:field_title) %>)</li>
    <li>description(<%= l(:field_description) %>)</li>
    <li>notes(Описание обноления к задаче) - применимо только для задачи</li>
  </ul>

  Если отметить галочку "Искать только в названиях",
  то поиск будет осуществлятся только по полю title(<%= l(:field_title) %>).

<h3><a id="phrase"><%= l('es.phrase') %></a></h3>

  Для поиска фразы возьмите её в двойные ковычки:

  <p class="search-phrase">"скорый поезд"</p>

<h3><a id="many_words"><%= l('es.many_words') %></a></h3>

  Для поиска нескольких слов введите их через пробел

  <p class="search-phrase">скорый поезд</p>

  Для поиска с нахождением всех слов отметьте галкой переключатель "Все слова"

<h3><a id="wildcards"><%= l('es.wildcards') %></a></h3>

  <p>
    Для поиска с подстановками можно использовать знак вопроса '?' для замены одного символа, и звездочку '*'
    для замены множества символов.
  </p>

  <p class="search-phrase">qu?ck bro*</p>

  <p>
    Знайте, что с масками запросы могут использовать огромное количество памяти и выполняться очень долго -
    просто подумайте, сколько термов должно быть запрошено для строки запроса "a* b* c*".
  </p>

<p>
  Внимание<br/>
  Запрос со звездочкой в начале слова (например, "*ing") является особенно тяжелым,
  потому что все термы в индексе должны быть проверены на совпадение.
</p>

<h3><a id="field"><%= l('es.field') %></a></h3>
  <p>
    Как упоминалось выше, по умолчанию поиск осуществляется по полям title, description и notes,
    но есть возможность указать для поиска и другие поля:
  </p>

  <ul>
    <li>
      поле статус содержит new
      <p class="search-phrase">status:new</p>
    </li>
    <li>
      поле title сожержит quick или brown
      <p class="search-phrase">title:(quick brown)</p>
    </li>
    <li>
      поле author сожержит точную фразу "John Smith"
      <p class="search-phrase">author:"John Smith"</p>
    </li>
    <li>
      где комментарий к задаче содержит quick или brown
      <p class="search-phrase">journals.notes:(quick brown)</p>
    </li>
    <li>
      где поле category не заполнено
      <p class="search-phrase">_missing_:category</p>
    </li>
    <li>
      где поле category заполнено
      <p class="search-phrase">_exists_:category</p>
    </li>
  </ul>

<h3><a id="text-attachments"><%= l('es.attachments') %></a></h3>
  <p>
    Можно искать задачи, проекты, новости, документы, вики странички и сообщения
    по содержимому приложенных файлов. Например поиск по имени файла приложения:
  </p>
  <p class="search-phrase">attachments.filename:somefile.pdf</p>
  <a href="#attachments">Список доступных полей в приложении</a>

<h3><a id="regular_expression"><%= l('es.regular_expression') %></a></h3>

  можно использовать регулярные выражения:

  <p class="search-phrase">author:/joh?n(ath[oa]n)/</p>

  Синтаксис поддерживаемых регулярных выражений подробно описан <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html#regexp-syntax">здесь</a>.

  <p>
    Внимание<br/>
    A query string such as the following would force Elasticsearch to visit every term in the index:
    Подобный запрос приведет к перебору всех термов в индексе.
  </p>

  <p class="search-phrase">/.*n/</p>

  Используйте осторожно!

<h3><a id="fuzziness"><%= l('es.fuzziness') %></a></h3>

  Мы можем захотеть найти слова которые похожи, а не четко соответствуют нашему запросу.
  Для этого можно использовать оператор "~":

  <p class="search-phrase">quikc~ brwn~ foks~</p>

  Этот запрос использует расстояние Дамерау — Левенштейна для поиска термов с одним или двумя изменениями,
  где изменение - вставка, удаление или транспозиция (перестановка двух соседних символов).

  По умолчанию используется расстояние 2, но расстояние 1 изменение покрывает примерно 80% всех опечаток.<br/>
  Расстояние 1 можно указать так:

  <p class="search-phrase">quikc~1</p>

<h3><a id="proximity_searches"><%= l('es.proximity_searches') %></a></h3>

  В то время как запрос для поиска фразы (например, "John Smith") приведет к поиску всех слов в том же порядке,
  запрос "похоже" позволяет искать фразу с указанными словами расположенными в другом порядке.
  Так же как для нечетких запросов можно указать максимальное
  расстояние изменения символов в слове, для запросов "похоже" можно
  указать максимальное расстояние изменения слов в фразе:

  <p class="search-phrase">"fox quick"~5</p>

<h3><a id="ranges"><%= l('es.ranges') %></a></h3>

  <p>
    Диапозоны могут быть указаны для полей с датами, цифрами и строками.
    Диапазон с включением граничных значений указывается с помощью квадратных скобок [min TO max],
    а диапазон не включающий граничные значения указывается с помощью фигурных скобок {min TO max}.
  </p>

  Весь 2013 год:

  <p class="search-phrase">datetime:[2013-01-01 TO 2013-12-31]</p>

  Числа от 1 до 5

  <p class="search-phrase">count:[1 TO 5]</p>

  Тэги alpha и omega, исключая alpha и omega:

  <p class="search-phrase">tags:{alpha TO omega}</p>

  Числа от 10

  <p class="search-phrase">count:[10 TO *]</p>

  Даты до 2014

  <p class="search-phrase">datetime:{* TO 2012-01-01}</p>

  Фигурные и квадратные скобки можно использовать вместе:<br/>
  Числа от 1 до 5, но не включая 5

  <p class="search-phrase">count:[1..5}</p>

  Для открытых диапазонов можно использовать следующий синтаксис:

  <p class="search-phrase">
    age:>10<br/>
    age:>=10<br/>
    age:<10<br/>
    age:<=10
  </p>

  <p class="search-phrase">
    age:(>=10 AND <20)<br/>
    age:(+>=10 +<20)
  </p>

<h3><a id="boosting"><%= l('es.boosting') %></a></h3>

  #todo

<h3><a id="boolean_operators"><%= l('es.boolean_operators') %></a></h3>

  <p>
    По умолчанию, все термы не являются обязательными, пока находится хоть один терм.
    Поиск "foo bar baz" найдет любой документ, который содержит один или более из foo bar baz.
    Есть логические операторы, которые можно использовать в самой строке запроса,
    чтобы обеспечить больший контроль.
  </p>
  <p>
    The preferred operators are + (this term must be present) and - (this term must not be present).
    All other terms are optional. For example, this query:

    Предпочтительные операторы это "+" (этот терм должен присутствовать) и "-" (этот терм не должен присутствовать).
    Все остальные условия не являются обязательными. Например, этот запрос:
  </p>

  <p class="search-phrase">quick brown +fox -news</p>

  <p>
    указывает что:<br/>

    fox должен присутствовать<br/>
    news не должен присутствовать<br/>
    quick и brown опциональные — их присутствие возможно
  </p>

  <p>
    Знакомые операторы "AND", "OR" и "NOT" (также "&&", "||" и "!"), также поддерживаются.
    Однако разобраться в действии этих операторов может быть сложнее, чем кажется на первый взгляд.
    "NOT" имеет преимущество над "AND", который имеет приоритет над "OR".
    В то время как + и - влияют только на терм справа от оператора,
    "AND" и "OR" влияют на термы слева и справа.
  </p>

<h3><a id="grouping"><%= l('es.grouping') %></a></h3>
  Несколько термов или выражений могут быть сгруппированы вместе с помощью круглых скобок для формирования подзапросов:

  <p class="search-phrase">(quick OR brown) AND fox</p>
  <p class="search-phrase">status:(active OR pending) title:(full text search)^2</p>

<h3><a id="reserved_characters"><%= l('es.reserved_characters') %></a></h3>

  <p>
    Если вам нужно использовать в поисковом запросе символы которые являются зарезервированными,
    то используйте "\" для экранирования. Например для поиска "(1+1)=2" можно написать такой запрос:
  </p>

  <p class="search-phrase">\(1\+1\)=2</p>

  <p>
    Список зарезервированных символов: + - && || ! ( ) { } [ ] ^ " ~ * ? : \ /
  </p>

<h3><a id="empty_query"><%= l('es.empty_query') %></a></h3>

  <p>
    Если строка запроса пуста или содержит только пробел строка запроса интерпретируется как no_docs_query и даст пустой результат.
  </p>
